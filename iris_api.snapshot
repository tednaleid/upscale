struct iris_image {
    int width;
    int height;
    int channels;       /* 3 for RGB, 4 for RGBA */
    uint8_t *data;      /* Row-major, channel-interleaved */
};

typedef struct {
    int width;              /* Output width (default: 256) */
    int height;             /* Output height (default: 256) */
    int num_steps;          /* Inference steps (default: 4 distilled, 50 base) */
    int64_t seed;           /* Random seed (-1 for random) */
    float guidance;         /* CFG guidance scale (0 = auto from model type) */
    int schedule;           /* Schedule type (IRIS_SCHEDULE_*) */
    float power_alpha;      /* Exponent for power schedule (default: 2.0) */
} iris_params;

enum {
    IRIS_SCHEDULE_DEFAULT   = 0,
    IRIS_SCHEDULE_LINEAR    = 1,
    IRIS_SCHEDULE_POWER     = 2,
    IRIS_SCHEDULE_SIGMOID   = 3,  /* Flux shifted sigmoid */
    IRIS_SCHEDULE_FLOWMATCH = 4,  /* Z-Image FlowMatch Euler */
};

iris_ctx *iris_load_dir(const char *model_dir);

void iris_free(iris_ctx *ctx);

void iris_set_mmap(iris_ctx *ctx, int enable);

iris_image *iris_image_load(const char *path);

int iris_image_save(const iris_image *img, const char *path);

int iris_image_save_with_seed(const iris_image *img, const char *path, int64_t seed);

void iris_image_free(iris_image *img);

iris_image *iris_generate(iris_ctx *ctx, const char *prompt,
                          const iris_params *params);

iris_image *iris_img2img(iris_ctx *ctx, const char *prompt,
                         const iris_image *input, const iris_params *params);

iris_image *iris_multiref(iris_ctx *ctx, const char *prompt,
                          const iris_image **refs, int num_refs,
                          const iris_params *params);

const char *iris_get_error(void);

void iris_set_step_image_callback(iris_ctx *ctx, iris_step_image_cb_t callback);

float *iris_encode_text(iris_ctx *ctx, const char *prompt, int *out_seq_len);

void iris_release_text_encoder(iris_ctx *ctx);

float *iris_encode_image(iris_ctx *ctx, const iris_image *img,
                         int *out_h, int *out_w);

int iris_is_distilled(iris_ctx *ctx);

iris_image *iris_img2img_precomputed(iris_ctx *ctx,
                                      const float *text_emb, int text_seq,
                                      const float *text_emb_uncond, int text_seq_uncond,
                                      const float *img_latent, int latent_h, int latent_w,
                                      const iris_params *params);

iris_image *iris_multiref_precomputed(iris_ctx *ctx,
                                       const float *text_emb, int text_seq,
                                       const float *text_emb_uncond, int text_seq_uncond,
                                       const float **ref_latents, const int *ref_hs,
                                       const int *ref_ws, int num_refs,
                                       const iris_params *params);

typedef enum {
    IRIS_SUBSTEP_DOUBLE_BLOCK,   /* Double-stream block completed */
    IRIS_SUBSTEP_SINGLE_BLOCK,   /* Single-stream block completed */
    IRIS_SUBSTEP_FINAL_LAYER,    /* Final layer completed */
} iris_substep_type_t;

typedef void (*iris_substep_callback_t)(iris_substep_type_t type, int index, int total);

typedef void (*iris_step_callback_t)(int step, int total);

typedef void (*iris_phase_callback_t)(const char *phase, int done);

extern iris_substep_callback_t iris_substep_callback;

extern iris_step_callback_t iris_step_callback;

extern iris_phase_callback_t iris_phase_callback;

typedef enum {
    TERM_PROTO_NONE = 0, /* No terminal graphics support detected */
    TERM_PROTO_KITTY,    /* Kitty graphics protocol (also used by Ghostty) */
    TERM_PROTO_ITERM2    /* iTerm2 inline image protocol */
} term_graphics_proto;

term_graphics_proto detect_terminal_graphics(void);

int terminal_display_image(const iris_image *img, term_graphics_proto proto);

int terminal_display_png(const char *path, term_graphics_proto proto);
